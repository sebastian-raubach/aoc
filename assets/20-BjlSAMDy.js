const e="Suddenly, the GPU contacts you, asking for help. Someone has asked it to simulate **too many particles**, and it won't be able to finish them all in time to render the next frame at this rate.\n\nIt transmits to you a buffer (your puzzle input) listing each particle in order (starting with particle `0`, then particle `1`, particle `2`, and so on). For each particle, it provides the `X`, `Y`, and `Z` coordinates for the particle's position (`p`), velocity (`v`), and acceleration (`a`), each in the format `<X,Y,Z>`.\n\nEach tick, all particles are updated simultaneously. A particle's properties are updated in the following order:\n\n- Increase the `X` velocity by the `X` acceleration.\n- Increase the `Y` velocity by the `Y` acceleration.\n- Increase the `Z` velocity by the `Z` acceleration.\n- Increase the `X` position by the `X` velocity.\n- Increase the `Y` position by the `Y` velocity.\n- Increase the `Z` position by the `Z` velocity.\n\nBecause of seemingly tenuous rationale involving [z-buffering](https://en.wikipedia.org/wiki/Z-buffering), the GPU would like to know which particle will stay closest to position `<0,0,0>` in the long term. Measure this using the [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry), which in this situation is simply the sum of the absolute values of a particle's `X`, `Y`, and `Z` position.\n\nFor example, suppose you are only given two particles, both of which stay entirely on the X-axis (for simplicity). Drawing the current states of particles `0` and `1` (in that order) with an adjacent a number line and diagram of current `X` positions (marked in parentheses), the following would take place:\n\n```\np=< 3,0,0>, v=< 2,0,0>, a=<-1,0,0>    -4 -3 -2 -1  0  1  2  3  4\np=< 4,0,0>, v=< 0,0,0>, a=<-2,0,0>                         (0)(1)\n\np=< 4,0,0>, v=< 1,0,0>, a=<-1,0,0>    -4 -3 -2 -1  0  1  2  3  4\np=< 2,0,0>, v=<-2,0,0>, a=<-2,0,0>                      (1)   (0)\n\np=< 4,0,0>, v=< 0,0,0>, a=<-1,0,0>    -4 -3 -2 -1  0  1  2  3  4\np=<-2,0,0>, v=<-4,0,0>, a=<-2,0,0>          (1)               (0)\n\np=< 3,0,0>, v=<-1,0,0>, a=<-1,0,0>    -4 -3 -2 -1  0  1  2  3  4\np=<-8,0,0>, v=<-6,0,0>, a=<-2,0,0>                         (0)   \n```\n\nAt this point, particle `1` will never be closer to `<0,0,0>` than particle `0`, and so, in the long run, particle `0` will stay closest.\n\n**Which particle will stay closest to position `<0,0,0>`** in the long term?\n\n[comment]: <> (PART 2)\n\nTo simplify the problem further, the GPU would like to remove any particles that **collide**. Particles collide if their positions ever **exactly match**. Because particles are updated simultaneously, **more than two particles** can collide at the same time and place. Once particles collide, they are removed and cannot collide with anything else after that tick.\n\nFor example:\n\n```\np=<-6,0,0>, v=< 3,0,0>, a=< 0,0,0>    \np=<-4,0,0>, v=< 2,0,0>, a=< 0,0,0>    -6 -5 -4 -3 -2 -1  0  1  2  3\np=<-2,0,0>, v=< 1,0,0>, a=< 0,0,0>    (0)   (1)   (2)            (3)\np=< 3,0,0>, v=<-1,0,0>, a=< 0,0,0>\n\np=<-3,0,0>, v=< 3,0,0>, a=< 0,0,0>    \np=<-2,0,0>, v=< 2,0,0>, a=< 0,0,0>    -6 -5 -4 -3 -2 -1  0  1  2  3\np=<-1,0,0>, v=< 1,0,0>, a=< 0,0,0>             (0)(1)(2)      (3)   \np=< 2,0,0>, v=<-1,0,0>, a=< 0,0,0>\n\np=< 0,0,0>, v=< 3,0,0>, a=< 0,0,0>    \np=< 0,0,0>, v=< 2,0,0>, a=< 0,0,0>    -6 -5 -4 -3 -2 -1  0  1  2  3\np=< 0,0,0>, v=< 1,0,0>, a=< 0,0,0>                       X (3)      \np=< 1,0,0>, v=<-1,0,0>, a=< 0,0,0>\n\n------destroyed by collision------    \n------destroyed by collision------    -6 -5 -4 -3 -2 -1  0  1  2  3\n------destroyed by collision------                      (3)         \np=< 0,0,0>, v=<-1,0,0>, a=< 0,0,0>\n```\n\nIn this example, particles `0`, `1`, and `2` are simultaneously destroyed at the time and place marked `X`. On the next tick, particle `3` passes through unharmed.\n\n**How many particles are left** after all collisions are resolved?";export{e as default};
