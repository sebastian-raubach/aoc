const e='As you see the Elves defend their hot chocolate successfully, you go back to falling through time. This is going to become a problem.\n\nIf you\'re ever going to return to your own time, you need to understand how this device on your wrist works. You have a little while before you reach your next destination, and with a bit of trial and error, you manage to pull up a programming manual on the device\'s tiny screen.\n\nAccording to the manual, the device has four [registers](https://en.wikipedia.org/wiki/Hardware_register) (numbered `0` through `3`) that can be manipulated by [instructions](https://en.wikipedia.org/wiki/Instruction_set_architecture#Instructions) containing one of 16 opcodes. The registers start with the value `0`.\n\nEvery instruction consists of four values: an **opcode**, two **inputs** (named `A` and `B`), and an **output** (named `C`), in that order. The opcode specifies the behavior of the instruction and how the inputs are interpreted. The output, C, is always treated as a register.\n\nIn the opcode descriptions below, if something says **"value `A`"**, it means to take the number given as `A` **literally**. (This is also called an "immediate" value.) If something says **"register `A`"**, it means to use the number given as `A` to read from (or write to) **the register with that number**. So, if the opcode `addi` adds register `A` and value `B`, storing the result in register `C`, and the instruction `addi 0 7 3` is encountered, it would add `7` to the value contained by register `0` and store the sum in register `3`, never modifying registers `0`, `1`, or `2` in the process.\n\nMany opcodes are similar except for how they interpret their arguments. The opcodes fall into seven general categories:\n\nAddition:\n\n- `addr` (add register) stores into register `C` the result of adding register `A` and register `B`.\n- `addi` (add immediate) stores into register `C` the result of adding register `A` and value `B`.\n\nMultiplication:\n\n- `mulr` (multiply register) stores into register `C` the result of multiplying register `A` and register `B`.\n- `muli` (multiply immediate) stores into register `C` the result of multiplying register `A` and value `B`.\n\nBitwise AND:\n\n- `banr` (bitwise AND register) stores into register `C` the result of the bitwise AND of register `A` and register `B`.\n- `bani` (bitwise AND immediate) stores into register `C` the result of the bitwise AND of register `A` and value `B`.\n\nBitwise OR:\n\n- `borr` (bitwise OR register) stores into register `C` the result of the bitwise OR of register `A` and register `B`.\n- `bori` (bitwise OR immediate) stores into register `C` the result of the bitwise OR of register `A` and value `B`.\n\nAssignment:\n\n- `setr` (set register) copies the contents of register `A` into register `C`. (Input `B` is ignored.)\n- `seti` (set immediate) stores value `A` into register `C`. (Input `B` is ignored.)\n\nGreater-than testing:\n\n- `gtir` (greater-than immediate/register) sets register `C` to `1` if value `A` is greater than register `B`. Otherwise, register `C` is set to `0`.\n- `gtri` (greater-than register/immediate) sets register `C` to `1` if register `A` is greater than value `B`. Otherwise, register `C` is set to `0`.\n- `gtrr` (greater-than register/register) sets register `C` to `1` if register `A` is greater than register `B`. Otherwise, register `C` is set to `0`.\n\nEquality testing:\n\n- `eqir` (equal immediate/register) sets register `C` to `1` if value `A` is equal to register `B`. Otherwise, register `C` is set to `0`.\n- `eqri` (equal register/immediate) sets register `C` to `1` if register `A` is equal to value `B`. Otherwise, register `C` is set to `0`.\n- `eqrr` (equal register/register) sets register `C` to `1` if register `A` is equal to register `B`. Otherwise, register `C` is set to `0`.\n\nUnfortunately, while the manual gives the **name** of each opcode, it doesn\'t seem to indicate the **number**. However, you can monitor the CPU to see the contents of the registers before and after instructions are executed to try to work them out. Each opcode has a number from `0` through `15`, but the manual doesn\'t say which is which. For example, suppose you capture the following sample:\n\n```\nBefore: [3, 2, 1, 1]\n9 2 1 2\nAfter:  [3, 2, 2, 1]\n```\n\nThis sample shows the effect of the instruction `9 2 1 2` on the registers. Before the instruction is executed, register `0` has value `3`, register `1` has value `2`, and registers `2` and `3` have value `1`. After the instruction is executed, register `2`\'s value becomes `2`.\n\nThe instruction itself, `9 2 1 2`, means that opcode `9` was executed with `A=2`, `B=1`, and `C=2`. Opcode `9` could be any of the 16 opcodes listed above, but only three of them behave in a way that would cause the result shown in the sample:\n\n- Opcode `9` could be `mulr`: register `2` (which has a value of `1`) times register `1` (which has a value of `2`) produces `2`, which matches the value stored in the output register, register 2.\n- Opcode `9` could be `addi`: register `2` (which has a value of `1`) plus value `1` produces `2`, which matches the value stored in the output register, register `2`.\n- Opcode `9` could be `seti`: value `2` matches the value stored in the output register, register `2`; the number given for `B` is irrelevant.\n\nNone of the other opcodes produce the result captured in the sample. Because of this, the sample above **behaves like three opcodes**.\n\nYou collect many of these samples (the first section of your puzzle input). The manual also includes a small test program (the second section of your puzzle input) - you can **ignore it for now**.\n\nIgnoring the opcode numbers, **how many samples in your puzzle input behave like three or more opcodes?**\n\n[comment]: <> (PART 2)\n\nUsing the samples you collected, work out the number of each opcode and execute the test program (the second section of your puzzle input).\n\n**What value is contained in register `0` after executing the test program?**';export{e as default};
