import{c as K,V as X}from"./color-Cgs3GWPp.js";import{a4 as I,v as Y,o as O,c as Z,a as tt,r as et,w as it,ab as H,a6 as rt,ah as st,a0 as ot}from"./index-D3fvFDxV.js";import{_ as nt}from"./_plugin-vue_export-helper-DlAUqK2U.js";var L={},x={},g={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 *
 * @class
 */let ht=class v{constructor(t,e,i){if(typeof t!="function")throw new Error("Heap constructor expects a compare function");this._compare=t,this._nodes=Array.isArray(e)?e:[],this._leaf=i||null}toArray(){return Array.from(this._nodes)}_hasLeftChild(t){return t*2+1<this.size()}_hasRightChild(t){return t*2+2<this.size()}_compareAt(t,e){return this._compare(this._nodes[t],this._nodes[e])}_swap(t,e){const i=this._nodes[t];this._nodes[t]=this._nodes[e],this._nodes[e]=i}_shouldSwap(t,e){return t<0||t>=this.size()||e<0||e>=this.size()?!1:this._compareAt(t,e)>0}_compareChildrenOf(t){if(!this._hasLeftChild(t)&&!this._hasRightChild(t))return-1;const e=t*2+1,i=t*2+2;return this._hasLeftChild(t)?this._hasRightChild(t)&&this._compareAt(e,i)>0?i:e:i}_compareChildrenBefore(t,e,i){return this._compareAt(i,e)<=0&&i<t?i:e}_heapifyUp(t){let e=t,i=Math.floor((e-1)/2);for(;this._shouldSwap(i,e);)this._swap(i,e),e=i,i=Math.floor((e-1)/2)}_heapifyDown(t){let e=t,i=this._compareChildrenOf(e);for(;this._shouldSwap(e,i);)this._swap(e,i),e=i,i=this._compareChildrenOf(e)}_heapifyDownUntil(t){let e=0,i=1,r=2,o;for(;i<t;)o=this._compareChildrenBefore(t,i,r),this._shouldSwap(e,o)&&this._swap(e,o),e=o,i=e*2+1,r=e*2+2}insert(t){return this._nodes.push(t),this._heapifyUp(this.size()-1),(this._leaf===null||this._compare(t,this._leaf)>0)&&(this._leaf=t),this}push(t){return this.insert(t)}extractRoot(){if(this.isEmpty())return null;const t=this.root();return this._nodes[0]=this._nodes[this.size()-1],this._nodes.pop(),this._heapifyDown(0),t===this._leaf&&(this._leaf=this.root()),t}pop(){return this.extractRoot()}sort(){for(let t=this.size()-1;t>0;t-=1)this._swap(0,t),this._heapifyDownUntil(t);return this._nodes}fix(){for(let t=Math.floor(this.size()/2)-1;t>=0;t-=1)this._heapifyDown(t);for(let t=Math.floor(this.size()/2);t<this.size();t+=1){const e=this._nodes[t];(this._leaf===null||this._compare(e,this._leaf)>0)&&(this._leaf=e)}return this}isValid(){const t=e=>{let i=!0,r=!0;if(this._hasLeftChild(e)){const o=e*2+1;if(this._compareAt(e,o)>0)return!1;i=t(o)}if(this._hasRightChild(e)){const o=e*2+2;if(this._compareAt(e,o)>0)return!1;r=t(o)}return i&&r};return t(0)}clone(){return new v(this._compare,this._nodes.slice(),this._leaf)}root(){return this.isEmpty()?null:this._nodes[0]}top(){return this.root()}leaf(){return this._leaf}size(){return this._nodes.length}isEmpty(){return this.size()===0}clear(){this._nodes=[],this._leaf=null}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("Heap.heapify expects an array of values");if(typeof e!="function")throw new Error("Heap.heapify expects a compare function");return new v(e,t).fix()}static isHeapified(t,e){return new v(e,t).isValid()}};g.Heap=ht;var U={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */const{Heap:Q}=g,q=h=>(t,e)=>{const i=typeof h=="function"?h(t):t,r=typeof h=="function"?h(e):e;return i<=r?-1:1};let at=class z{constructor(t,e){this._getCompareValue=t,this._heap=e||new Q(q(t))}toArray(){return Array.from(this._heap._nodes)}insert(t){return this._heap.insert(t)}push(t){return this.insert(t)}extractRoot(){return this._heap.extractRoot()}pop(){return this.extractRoot()}sort(){return this._heap.sort()}fix(){return this._heap.fix()}isValid(){return this._heap.isValid()}root(){return this._heap.root()}top(){return this.root()}leaf(){return this._heap.leaf()}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}clone(){return new z(this._getCompareValue,this._heap.clone())}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("MinHeap.heapify expects an array");const i=new Q(q(e),t);return new z(e,i).fix()}static isHeapified(t,e){const i=new Q(q(e),t);return new z(e,i).isValid()}};U.MinHeap=at;var N={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */const{Heap:R}=g,S=h=>(t,e)=>{const i=typeof h=="function"?h(t):t,r=typeof h=="function"?h(e):e;return i<r?1:-1};let pt=class ${constructor(t,e){this._getCompareValue=t,this._heap=e||new R(S(t))}insert(t){return this._heap.insert(t)}push(t){return this.insert(t)}extractRoot(){return this._heap.extractRoot()}pop(){return this.extractRoot()}sort(){return this._heap.sort()}toArray(){return Array.from(this._heap._nodes)}fix(){return this._heap.fix()}isValid(){return this._heap.isValid()}root(){return this._heap.root()}top(){return this.root()}leaf(){return this._heap.leaf()}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}clone(){return new $(this._getCompareValue,this._heap.clone())}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("MaxHeap.heapify expects an array");const i=new R(S(e),t);return new $(e,i).fix()}static isHeapified(t,e){const i=new R(S(e),t);return new $(e,i).isValid()}};N.MaxHeap=pt;const{Heap:ct}=g,{MinHeap:ut}=U,{MaxHeap:ft}=N;x.Heap=ct;x.MinHeap=ut;x.MaxHeap=ft;/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:lt,MinHeap:B}=x,_t=h=>(t,e)=>{const i=typeof h=="function"?h(t):t,r=typeof h=="function"?h(e):e;return i<=r?-1:1};let dt=class V{constructor(t,e){if(t&&typeof t!="function")throw new Error("MinPriorityQueue constructor requires a callback for object values");this._heap=e||new B(t)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if(typeof t!="function")throw new Error("MinPriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const r=this.pop();t(r)?e.push(r):i.push(r)}return i.forEach(r=>this.push(r)),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static fromArray(t,e){const i=new lt(_t(e),t);return new V(e,new B(e,i).fix())}};L.MinPriorityQueue=dt;var j={};/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:yt,MaxHeap:D}=x,xt=h=>(t,e)=>{const i=typeof h=="function"?h(t):t,r=typeof h=="function"?h(e):e;return i<r?1:-1};let wt=class F{constructor(t,e){if(t&&typeof t!="function")throw new Error("MaxPriorityQueue constructor requires a callback for object values");this._heap=e||new D(t)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if(typeof t!="function")throw new Error("MaxPriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const r=this.pop();t(r)?e.push(r):i.push(r)}return i.forEach(r=>this.push(r)),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static fromArray(t,e){const i=new yt(xt(e),t);return new F(e,new D(e,i).fix())}};j.MaxPriorityQueue=wt;var W={};/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:mt}=x;let Mt=class G{constructor(t,e){if(typeof t!="function")throw new Error("PriorityQueue constructor expects a compare function");this._heap=new mt(t,e),e&&this._heap.fix()}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if(typeof t!="function")throw new Error("PriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const r=this.pop();t(r)?e.push(r):i.push(r)}return i.forEach(r=>this.push(r)),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static fromArray(t,e){return new G(e,t)}};W.PriorityQueue=Mt;const{MinPriorityQueue:Et}=L,{MaxPriorityQueue:Ht}=j,{PriorityQueue:vt}=W;var zt={MinPriorityQueue:Et,MaxPriorityQueue:Ht,PriorityQueue:vt};const $t={id:"holder",class:"canvas-holder"},gt=I({__name:"V16",props:{grid:{},path:{},onPath:{}},setup(h){const t=h,e=()=>{var c;const i=Math.max(1,Math.floor((((c=document.getElementById("holder"))==null?void 0:c.offsetWidth)||1)/t.grid[0].length)),r=document.getElementById("partOne"),o=r.getContext("2d");r.width=t.grid[0].length*i+1,r.height=t.grid.length*i+1,o.translate(.5,.5),o.lineWidth=.5,o.fillStyle="#222222",o.fillRect(0,0,r.width,r.height);for(let a=0;a<t.grid.length;a++)for(let p=0;p<t.grid[a].length;p++)t.grid[a][p]==="."?o.fillStyle="#2f3542":t.grid[a][p]==="#"&&(o.fillStyle="#57606f"),o.fillRect(p*i,a*i,i,i);const P=K(X,t.path[t.path.length-1].cost+1);t.path.forEach(a=>{o.fillStyle=P[a.cost],o.fillRect(a.position.x*i,a.position.y*i,i,i)}),o.fillStyle="#57606f",t.onPath.forEach(a=>{const[p,w]=a.split("|").map(Number);o.beginPath(),o.arc(p*i+i/2,w*i+i/2,i/4,0,2*Math.PI),o.fill()})};return Y(()=>e()),(i,r)=>(O(),Z("div",$t,r[0]||(r[0]=[tt("canvas",{id:"partOne",class:"canvas",height:"500",width:"500"},null,-1)])))}}),Pt=nt(gt,[["__scopeId","data-v-e17ef0ec"]]),St=I({__name:"D16",props:{input:{}},emits:["onFinished"],setup(h,{emit:t}){const e=h,i=t,r=et(!1),o={">":["^","v"],"<":["^","v"],"^":["<",">"],v:["<",">"]},P={">":[1,0],"<":[-1,0],"^":[0,-1],v:[0,1]},c={x:0,y:0},a={x:0,y:0};let p,w;const m=new Set,T=()=>{var d,b,k;const M=(E,f)=>E.cost-f.cost,l=new zt.PriorityQueue(M),_={};let u=0;l.enqueue({position:{x:c.x,y:c.y},cost:0,path:[{position:{x:c.x,y:c.y},cost:0,facing:">"}],facing:">"}),_[`${c.x}|${c.y}|>`]=0;let n;for(;l.size()>0;){if(n=l.dequeue(),n.position.x===a.x&&n.position.y===a.y){u===0?(u=n.cost,(d=n.path)==null||d.forEach(s=>m.add(`${s.position.x}|${s.position.y}`)),w=n.path||[]):n.cost===u&&((b=n.path)==null||b.forEach(s=>m.add(`${s.position.x}|${s.position.y}`)));continue}const E=P[n.facing||">"],f={x:n.position.x+E[0],y:n.position.y+E[1]};if(f.x<0||f.y<0||f.x>=p[0].length||f.y>=p.length)continue;const A=[];if(p[f.y][f.x]==="."){const s=((k=n.path)==null?void 0:k.concat())||[];s.push({position:f,cost:n.cost+1,facing:n.facing}),A.push({position:f,facing:n.facing,cost:n.cost+1,path:s})}o[n.facing||">"].forEach(s=>{var C;const y=((C=n.path)==null?void 0:C.concat())||[];y.push({position:n.position,cost:n.cost+1e3,facing:s}),A.push({position:n.position,facing:s,cost:n.cost+1e3,path:y})}),A.forEach(s=>{const y=_[`${s.position.x}|${s.position.y}|${s.facing}`];(u===0||s.cost<=u)&&(y==null?(l.enqueue(s),_[`${s.position.x}|${s.position.y}|${s.facing}`]=s.cost):s.cost<=y&&(l.enqueue(s),_[`${s.position.x}|${s.position.y}|${s.facing}`]=s.cost))})}return u},J=()=>{if(e.input){p=e.input.map((l,_)=>{const u=l.split("");return u.forEach((n,d)=>{n==="S"?(u[d]=".",c.x=d,c.y=_):n==="E"&&(u[d]=".",a.x=d,a.y=_)}),u});const M=T();i("onFinished",M,m.size),ot(()=>{r.value=!0})}};return it(()=>e.input,()=>J(),{immediate:!0}),(M,l)=>H(r)?(O(),rt(Pt,{key:0,grid:H(p),"on-path":H(m),path:H(w)},null,8,["grid","on-path","path"])):st("",!0)}});export{St as default};
