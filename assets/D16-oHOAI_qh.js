import{c as K,V as X,a as Y}from"./color-Cgs3GWPp.js";import{a4 as O,v as Z,o as L,c as tt,a as et,r as it,w as rt,ab as H,a6 as st,ah as ot,a0 as nt}from"./index-Mb-YhgmZ.js";import{_ as ht}from"./_plugin-vue_export-helper-DlAUqK2U.js";var U={},m={},g={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 *
 * @class
 */let at=class v{constructor(t,e,i){if(typeof t!="function")throw new Error("Heap constructor expects a compare function");this._compare=t,this._nodes=Array.isArray(e)?e:[],this._leaf=i||null}toArray(){return Array.from(this._nodes)}_hasLeftChild(t){return t*2+1<this.size()}_hasRightChild(t){return t*2+2<this.size()}_compareAt(t,e){return this._compare(this._nodes[t],this._nodes[e])}_swap(t,e){const i=this._nodes[t];this._nodes[t]=this._nodes[e],this._nodes[e]=i}_shouldSwap(t,e){return t<0||t>=this.size()||e<0||e>=this.size()?!1:this._compareAt(t,e)>0}_compareChildrenOf(t){if(!this._hasLeftChild(t)&&!this._hasRightChild(t))return-1;const e=t*2+1,i=t*2+2;return this._hasLeftChild(t)?this._hasRightChild(t)&&this._compareAt(e,i)>0?i:e:i}_compareChildrenBefore(t,e,i){return this._compareAt(i,e)<=0&&i<t?i:e}_heapifyUp(t){let e=t,i=Math.floor((e-1)/2);for(;this._shouldSwap(i,e);)this._swap(i,e),e=i,i=Math.floor((e-1)/2)}_heapifyDown(t){let e=t,i=this._compareChildrenOf(e);for(;this._shouldSwap(e,i);)this._swap(e,i),e=i,i=this._compareChildrenOf(e)}_heapifyDownUntil(t){let e=0,i=1,r=2,o;for(;i<t;)o=this._compareChildrenBefore(t,i,r),this._shouldSwap(e,o)&&this._swap(e,o),e=o,i=e*2+1,r=e*2+2}insert(t){return this._nodes.push(t),this._heapifyUp(this.size()-1),(this._leaf===null||this._compare(t,this._leaf)>0)&&(this._leaf=t),this}push(t){return this.insert(t)}extractRoot(){if(this.isEmpty())return null;const t=this.root();return this._nodes[0]=this._nodes[this.size()-1],this._nodes.pop(),this._heapifyDown(0),t===this._leaf&&(this._leaf=this.root()),t}pop(){return this.extractRoot()}sort(){for(let t=this.size()-1;t>0;t-=1)this._swap(0,t),this._heapifyDownUntil(t);return this._nodes}fix(){for(let t=Math.floor(this.size()/2)-1;t>=0;t-=1)this._heapifyDown(t);for(let t=Math.floor(this.size()/2);t<this.size();t+=1){const e=this._nodes[t];(this._leaf===null||this._compare(e,this._leaf)>0)&&(this._leaf=e)}return this}isValid(){const t=e=>{let i=!0,r=!0;if(this._hasLeftChild(e)){const o=e*2+1;if(this._compareAt(e,o)>0)return!1;i=t(o)}if(this._hasRightChild(e)){const o=e*2+2;if(this._compareAt(e,o)>0)return!1;r=t(o)}return i&&r};return t(0)}clone(){return new v(this._compare,this._nodes.slice(),this._leaf)}root(){return this.isEmpty()?null:this._nodes[0]}top(){return this.root()}leaf(){return this._leaf}size(){return this._nodes.length}isEmpty(){return this.size()===0}clear(){this._nodes=[],this._leaf=null}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("Heap.heapify expects an array of values");if(typeof e!="function")throw new Error("Heap.heapify expects a compare function");return new v(e,t).fix()}static isHeapified(t,e){return new v(e,t).isValid()}};g.Heap=at;var N={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */const{Heap:q}=g,R=h=>(t,e)=>{const i=typeof h=="function"?h(t):t,r=typeof h=="function"?h(e):e;return i<=r?-1:1};let ct=class z{constructor(t,e){this._getCompareValue=t,this._heap=e||new q(R(t))}toArray(){return Array.from(this._heap._nodes)}insert(t){return this._heap.insert(t)}push(t){return this.insert(t)}extractRoot(){return this._heap.extractRoot()}pop(){return this.extractRoot()}sort(){return this._heap.sort()}fix(){return this._heap.fix()}isValid(){return this._heap.isValid()}root(){return this._heap.root()}top(){return this.root()}leaf(){return this._heap.leaf()}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}clone(){return new z(this._getCompareValue,this._heap.clone())}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("MinHeap.heapify expects an array");const i=new q(R(e),t);return new z(e,i).fix()}static isHeapified(t,e){const i=new q(R(e),t);return new z(e,i).isValid()}};N.MinHeap=ct;var V={};/**
 * @license MIT
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 */const{Heap:b}=g,S=h=>(t,e)=>{const i=typeof h=="function"?h(t):t,r=typeof h=="function"?h(e):e;return i<r?1:-1};let pt=class ${constructor(t,e){this._getCompareValue=t,this._heap=e||new b(S(t))}insert(t){return this._heap.insert(t)}push(t){return this.insert(t)}extractRoot(){return this._heap.extractRoot()}pop(){return this.extractRoot()}sort(){return this._heap.sort()}toArray(){return Array.from(this._heap._nodes)}fix(){return this._heap.fix()}isValid(){return this._heap.isValid()}root(){return this._heap.root()}top(){return this.root()}leaf(){return this._heap.leaf()}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}clone(){return new $(this._getCompareValue,this._heap.clone())}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static heapify(t,e){if(!Array.isArray(t))throw new Error("MaxHeap.heapify expects an array");const i=new b(S(e),t);return new $(e,i).fix()}static isHeapified(t,e){const i=new b(S(e),t);return new $(e,i).isValid()}};V.MaxHeap=pt;const{Heap:ut}=g,{MinHeap:lt}=N,{MaxHeap:ft}=V;m.Heap=ut;m.MinHeap=lt;m.MaxHeap=ft;/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:dt,MinHeap:D}=m,_t=h=>(t,e)=>{const i=typeof h=="function"?h(t):t,r=typeof h=="function"?h(e):e;return i<=r?-1:1};let yt=class j{constructor(t,e){if(t&&typeof t!="function")throw new Error("MinPriorityQueue constructor requires a callback for object values");this._heap=e||new D(t)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if(typeof t!="function")throw new Error("MinPriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const r=this.pop();t(r)?e.push(r):i.push(r)}return i.forEach(r=>this.push(r)),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static fromArray(t,e){const i=new dt(_t(e),t);return new j(e,new D(e,i).fix())}};U.MinPriorityQueue=yt;var F={};/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:xt,MaxHeap:I}=m,wt=h=>(t,e)=>{const i=typeof h=="function"?h(t):t,r=typeof h=="function"?h(e):e;return i<r?1:-1};let mt=class G{constructor(t,e){if(t&&typeof t!="function")throw new Error("MaxPriorityQueue constructor requires a callback for object values");this._heap=e||new I(t)}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if(typeof t!="function")throw new Error("MaxPriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const r=this.pop();t(r)?e.push(r):i.push(r)}return i.forEach(r=>this.push(r)),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static fromArray(t,e){const i=new xt(wt(e),t);return new G(e,new I(e,i).fix())}};F.MaxPriorityQueue=mt;var W={};/**
 * @copyright 2020 Eyas Ranjous <eyas.ranjous@gmail.com>
 * @license MIT
 */const{Heap:Mt}=m;let Et=class T{constructor(t,e){if(typeof t!="function")throw new Error("PriorityQueue constructor expects a compare function");this._heap=new Mt(t,e),e&&this._heap.fix()}front(){return this._heap.root()}back(){return this._heap.leaf()}enqueue(t){return this._heap.insert(t)}push(t){return this.enqueue(t)}dequeue(){return this._heap.extractRoot()}pop(){return this.dequeue()}remove(t){if(typeof t!="function")throw new Error("PriorityQueue remove expects a callback");const e=[],i=[];for(;!this.isEmpty();){const r=this.pop();t(r)?e.push(r):i.push(r)}return i.forEach(r=>this.push(r)),e}size(){return this._heap.size()}isEmpty(){return this._heap.isEmpty()}clear(){this._heap.clear()}toArray(){return this._heap.clone().sort().reverse()}[Symbol.iterator](){let t=this.size();return{next:()=>(t-=1,{value:this.pop(),done:t===-1})}}static fromArray(t,e){return new T(e,t)}};W.PriorityQueue=Et;const{MinPriorityQueue:Ht}=U,{MaxPriorityQueue:vt}=F,{PriorityQueue:zt}=W;var $t={MinPriorityQueue:Ht,MaxPriorityQueue:vt,PriorityQueue:zt};const gt={id:"holder",class:"canvas-holder"},Pt=O({__name:"V16",props:{grid:{},path:{},onPath:{}},setup(h){const t=h,e=()=>{var f;const i=Math.max(1,Math.floor((((f=document.getElementById("holder"))==null?void 0:f.offsetWidth)||1)/t.grid[0].length)),r=document.getElementById("partOne"),o=r.getContext("2d");r.width=t.grid[0].length*i+1,r.height=t.grid.length*i+1,o.translate(.5,.5),o.lineWidth=.5,o.fillStyle="#222222",o.fillRect(0,0,r.width,r.height);for(let a=0;a<t.grid.length;a++)for(let c=0;c<t.grid[a].length;c++)t.grid[a][c]==="."?o.fillStyle="#2f3542":t.grid[a][c]==="#"&&(o.fillStyle="#57606f"),o.fillRect(c*i,a*i,i,i);const P=K(X,t.path[t.path.length-1].cost+1),u=Y("#ced6e0","#747d8c",t.onPath.size+1);t.path.forEach(a=>{o.fillStyle=P[a.cost],o.fillRect(a.position.x*i,a.position.y*i,i,i)});let x=0;t.onPath.forEach(a=>{o.fillStyle=u[x++];const[c,A]=a.split("|").map(Number);o.beginPath(),o.arc(c*i+i/2,A*i+i/2,i/4,0,2*Math.PI),o.fill()})};return Z(()=>e()),(i,r)=>(L(),tt("div",gt,r[0]||(r[0]=[et("canvas",{id:"partOne",class:"canvas",height:"500",width:"500"},null,-1)])))}}),At=ht(Pt,[["__scopeId","data-v-3e2f5725"]]),St=O({__name:"D16",props:{input:{}},emits:["onFinished"],setup(h,{emit:t}){const e=h,i=t,r=it(!1),o={">":["^","v"],"<":["^","v"],"^":["<",">"],v:["<",">"]},P={">":[1,0],"<":[-1,0],"^":[0,-1],v:[0,1]},u={x:0,y:0},x={x:0,y:0};let f,a;const c=new Set,A=()=>{var y,k,C;const M=(E,l)=>E.cost-l.cost,d=new $t.PriorityQueue(M),_={};let p=0;d.enqueue({position:{x:u.x,y:u.y},cost:0,path:[{position:{x:u.x,y:u.y},cost:0,facing:">"}],facing:">"}),_[`${u.x}|${u.y}|>`]=0;let n;for(;d.size()>0;){if(n=d.dequeue(),n.position.x===x.x&&n.position.y===x.y){p===0?(p=n.cost,(y=n.path)==null||y.forEach(s=>c.add(`${s.position.x}|${s.position.y}`))):n.cost===p&&((k=n.path)==null||k.forEach(s=>c.add(`${s.position.x}|${s.position.y}`))),a=n.path||[];continue}const E=P[n.facing||">"],l={x:n.position.x+E[0],y:n.position.y+E[1]};if(l.x<0||l.y<0||l.x>=f[0].length||l.y>=f.length)continue;const Q=[];if(f[l.y][l.x]==="."){const s=((C=n.path)==null?void 0:C.concat())||[];s.push({position:l,cost:n.cost+1,facing:n.facing}),Q.push({position:l,facing:n.facing,cost:n.cost+1,path:s})}o[n.facing||">"].forEach(s=>{var B;const w=((B=n.path)==null?void 0:B.concat())||[];w.push({position:n.position,cost:n.cost+1e3,facing:s}),Q.push({position:n.position,facing:s,cost:n.cost+1e3,path:w})}),Q.forEach(s=>{const w=_[`${s.position.x}|${s.position.y}|${s.facing}`];(p===0||s.cost<=p)&&(w==null?(d.enqueue(s),_[`${s.position.x}|${s.position.y}|${s.facing}`]=s.cost):s.cost<=w&&(d.enqueue(s),_[`${s.position.x}|${s.position.y}|${s.facing}`]=s.cost))})}return p},J=()=>{if(e.input){f=e.input.map((d,_)=>{const p=d.split("");return p.forEach((n,y)=>{n==="S"?(p[y]=".",u.x=y,u.y=_):n==="E"&&(p[y]=".",x.x=y,x.y=_)}),p});const M=A();i("onFinished",M,c.size),nt(()=>{r.value=!0})}};return rt(()=>e.input,()=>J(),{immediate:!0}),(M,d)=>H(r)?(L(),st(At,{key:0,grid:H(f),"on-path":H(c),path:H(a)},null,8,["grid","on-path","path"])):ot("",!0)}});export{St as default};
